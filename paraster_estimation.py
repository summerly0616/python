import numpy as np
import pandas as pd
import heapq
from scipy.integrate import odeint
from scipy.signal import find_peaks

#%% Pseudo random number generated by Sobol algorithm
file1 = pd.read_csv('circadian_parameter_estimation_input.csv', header=None, sep=',')
df1 = pd.DataFrame(file1)
v1_0 = np.array(df1[0])
v1L_0 = np.array(df1[1])
v1A_0 = np.array(df1[2])
v2A_0 = np.array(df1[3])
v2L_0 = np.array(df1[4])
v2B_0 = np.array(df1[5])
v3_0 = np.array(df1[6])
v3B_0 = np.array(df1[7])
v4_0 = np.array(df1[8])
v4L_0 = np.array(df1[9])
k1L_0 = np.array(df1[10])
k1D_0 = np.array(df1[11])
k2_0 = np.array(df1[12])
k3_0 = np.array(df1[13])
k4_0 = np.array(df1[14])
p1_0 = np.array(df1[15])
p1L_0 = np.array(df1[16])
p2_0 = np.array(df1[17])
p3_0 = np.array(df1[18])
p4_0 = np.array(df1[19])
d1_0 = np.array(df1[20])
d2D_0 = np.array(df1[21])
d2L_0 = np.array(df1[22])
d3D_0 = np.array(df1[23])
d3L_0 = np.array(df1[24])
d4D_0 = np.array(df1[25])
d4L_0 = np.array(df1[26])
K0_0 = np.array(df1[27])
K1_0 = np.array(df1[28])
K2_0 = np.array(df1[29])
K2a_0 = np.array(df1[30])
K3_0 = np.array(df1[31])
K4_0 = np.array(df1[32])
K5_0 = np.array(df1[33])
K5b_0 = np.array(df1[34])
K6_0 = np.array(df1[35])
K7_0 = np.array(df1[36])
K7a_0 = np.array(df1[37])
K8_0 = np.array(df1[38])
K9_0 = np.array(df1[39])
K10_0 = np.array(df1[40])

#%% circadian clock genes expressions input
file2 = pd.read_csv('circadian_clock.csv', header=None, sep=',')
df2 = pd.DataFrame(file2)
Time = np.array(df2[0])
y_CCA1 = np.array(df2[1])
y_PRR9 = np.array(df2[2])
y_PRR5 = np.array(df2[3])
y_ELF4 = np.array(df2[4])

#%%  light/dark cycle input

def lightdark(t):
    if t>168:
        L = 1
        D = 0
    elif np.mod(t,24)>=12:
        L = 0
        D = 1
    else:
        L = 1
        D = 0  
    return L,D


#%% main equations 
def f(y, t, v1, v1L, v1A, v2A, v2L, v2B, v3, v3B, v4, v4L, k1L, k1D, k2, k3, k4, p1, p1L, p2, p3, p4, d1, d2D, d2L, d3D, d3L, d4D, d4L, K0, K1, K2, K2a, K3, K4, K5, K5b, K6, K7, K7a, K8, K9, K10):
    CLm  = y[0]
    CLp  = y[1]
    P97m = y[2]
    P97p = y[3]
    P51m = y[4]
    P51p = y[5]
    ELm  = y[6]
    ELp  = y[7]
    P    = y[8]    
    L,D = lightdark(t)

    a1=0.55
    b1=0.08
    a2=0.1
    b2 =0.1
    c=0.82
    LWD = a1*np.sin(2*np.pi/24.6*(t+8))+b1*np.cos(2*np.pi/24.6*(t+8))+a2*np.sin(2*np.pi/24.6*(2*t+8))+b2*np.cos(2*np.pi/24.6*(2*t+8))+c
   

     
    z=np.array([(v1+v1L*L*P+v1A*(LWD/K2a)**2/(1+(LWD/K2a)**2))/(1+(CLp/K0)**2+(P97p/K1)**2+(P51p/K2)**2)-(k1L*L+k1D*D)*CLm,\
               (p1+p1L*L)*CLm-d1*CLp,\
               (v2L*L*P+v2A+v2B*(LWD/K5b)**2/(1+(LWD/K5b)**2))/(1+(CLp/K3)**2+(P51p/K4)**2+(ELp/K5)**2)-k2*P97m,\
               p2*P97m-(d2D*D+d2L*L)*P97p,\
               (v3+v3B*(LWD/K7a)**2/(1+(LWD/K7a)**2))/(1+(CLp/K6)**2+(P51p/K7)**2)-k3*P51m,\
               p3*P51m-(d3D*D+d3L*L)*P51p,\
               (v4+L*v4L)/(1+(CLp/K8)**2+(P51p/K9)**2+(ELp/K10)**2)-k4*ELm,\
               p4*ELm-(d4D*D+d4L*L)*ELp,\
               0.3*(1-P)*D-P*L])
       
   
    return z


#%% cost function
def SSE(z):
    SSE_CCA1 = 0
    SSE_PRR9 = 0
    SSE_PRR5 = 0
    SSE_ELF4 = 0

    Z_CCA1 = y_CCA1 / max(y_CCA1)
    Z_PRR9 = y_PRR9 / max(y_PRR9)
    Z_PRR5 = y_PRR5 / max(y_PRR5)
    Z_ELF4 = y_ELF4 / max(y_ELF4)

    Y_CL = z[:, 0] / max(z[40800:48000, 0])
    Y_P97 = z[:, 2] / max(z[40800:48000, 2])
    Y_P51 = z[:, 4] / max(z[40800:48000, 4])
    Y_EL = z[:, 6] / max(z[40800:48000, 6])

    j = 0
    for i in Time:
        SSE_CCA1 += (Y_CL[i] - Z_CCA1[j]) ** 2
        SSE_PRR9 += (Y_P97[i] - Z_PRR9[j]) ** 2
        SSE_PRR5 += (Y_P51[i] - Z_PRR5[j]) ** 2
        SSE_ELF4 += (Y_EL[i] - Z_ELF4[j]) ** 2
        j += 1

    SSE = SSE_CCA1 + SSE_PRR9 + SSE_PRR5 + SSE_ELF4

    return SSE


def cost_function(y):
    delt1 = SSE(y)

    Y_CL = y[:, 0] / max(y[40800:48000, 0])
    Y_P97 = y[:, 2] / max(y[40800:48000, 2])
    Y_P51 = y[:, 4] / max(y[40800:48000, 4])
    Y_EL = y[:, 4] / max(y[40800:48000, 6])
    

  
    # phases of circadian genes
    peak_id_CL, peak_property_CL = find_peaks(Y_CL[48000:], height=0)
    peak_id_P97, peak_property_P97 = find_peaks(Y_P97[48000:], height=0)
    peak_id_P51, peak_property_P51 = find_peaks(Y_P51[48000:], height=0)
    peak_id_EL, peak_property_EL = find_peaks(Y_EL[48000:], height=0)
    peak_CL = np.mean(np.mod((48000 + peak_id_CL) / 100, 24))
    peak_P97=np.mean(np.mod((48000+peak_id_P97)/100,24))
    peak_P51=np.mean(np.mod((48000+peak_id_P51)/100,24))
    peak_EL=np.mean(np.mod((48000+peak_id_EL)/100,24))
    
    
    trough_id_CL, trough_property_CL = find_peaks(max(Y_CL[48000:]) - Y_CL[48000:], height=0)
    trough_id_P97, trough_property_P97 = find_peaks(max(Y_P97[48000:]) - Y_P97[48000:], height=0)
    trough_id_P51, trough_property_P51 = find_peaks(max(Y_P51[48000:]) - Y_P51[48000:], height=0)
    trough_id_EL, trough_property_EL = find_peaks(max(Y_EL[48000:]) - Y_EL[48000:], height=0)
    trough_CL = np.mean(np.mod((48000 + trough_id_CL) / 100, 24))
    trough_P97 = np.mean(np.mod((48000 + trough_id_P97) / 100, 24))
    trough_P51 = np.mean(np.mod((48000 + trough_id_P51) / 100, 24))
    trough_EL = np.mean(np.mod((48000 + trough_id_EL) / 100, 24))
    
   
    # periods of circadian genes
    diff_CL = np.diff((48000 + peak_id_CL) / 100)
    diff_P97 = np.diff((48000 + peak_id_P97) / 100)
    diff_P51 = np.diff((48000 + peak_id_P51) / 100)
    diff_EL = np.diff((48000 + peak_id_EL) / 100)
    period_CL = np.mean(abs(diff_CL))
    period_P97 = np.mean(abs(diff_P97))
    period_P51 = np.mean(abs(diff_P51))
    period_EL = np.mean(abs(diff_EL))
   
    if abs(period_CL - 25.5) > 2 or abs(period_P97 - 25.5) > 2 or abs(period_P51 - 25.5) > 2 or \
            abs(period_EL - 25.5) > 2 :
        delt = 20000
    elif np.mean(Y_CL[48000 + peak_id_CL]) - np.mean(Y_CL[48000 + trough_id_CL]) < 0.1 or \
            np.mean(Y_P97[48000 + peak_id_P97]) - np.mean(Y_P97[48000 + trough_id_P97]) < 0.1 or \
            np.mean(Y_P51[48000 + peak_id_P51]) - np.mean(Y_P51[48000 + trough_id_P51]) < 0.1 or \
            np.mean(Y_EL[48000 + peak_id_EL]) - np.mean(Y_EL[48000 + trough_id_EL]) < 0.1 :
        delt = 10000
    else:
        delt2 = ((period_CL - 25.5) / (0.1 * 24)) ** 2 + ((period_P97 - 25.5) / (0.1 * 24)) ** 2+ ((period_P51 - 25.5) / (0.1 * 24)) ** 2+ ((period_EL - 25.5) / (0.1 * 24)) ** 2
        delt3 = np.mean(((peak_CL - 2.0) / (0.1 * 24)) ** 2) + np.mean(((peak_P97 - 10) / (0.1 * 24)) ** 2) + np.mean(((peak_P51 - 11.5) / (0.1 * 24)) ** 2) + np.mean(((peak_EL - 16) / (0.1 * 24)) ** 2) +\
                np.mean(((trough_CL - 15) / (0.1 * 24)) ** 2) + np.mean(((trough_P97 - 23) / (0.1 * 24)) ** 2)+ np.mean(((trough_P51 - 24) / (0.1 * 24)) ** 2)+ np.mean(((trough_EL - 6) / (0.1 * 24)) ** 2)
        delt = delt1 + delt2 + delt3

    return delt


#%% 
if __name__ == '__main__':
    y0 = np.array([0.85371592e+00, 1.72626332e+00, 5.01968466e-01, 6.46276320e-01,2.25236529e-01, 5.94439074e-01, 1.27049114e-04, 2.01664004e-04, 9.91522441e-01])
    h = 0.01
    tspan = np.array([0, 600])
    t = np.arange(tspan[0], tspan[1], h)

    delt = []
    for i in range(100000):
        v1, v1L, v1A, v2A, v2L, v2B, v3, v3B, v4, v4L, k1L, k1D, k2, k3, k4, p1, p1L, p2, p3, p4, d1, d2D, d2L, d3D, d3L, d4D, d4L, K0, K1, K2, K2a, K3, K4, K5, K5b, K6, K7, K7a, K8, K9, K10 = \
            float(v1_0[i]), float(v1L_0[i]), float(v1A_0[i]), float(v2A_0[i]), float(v2L_0[i]), float(v2B_0[i]), float(v3_0[i]), float(v3B_0[i]), float(v4_0[i]), float(v4L_0[i]), \
                float(k1L_0[i]), float(k1D_0[i]), float(k2_0[i]), float(k3_0[i]), float(k4_0[i]), float(p1_0[i]), float(p1L_0[i]), float(p2_0[i]), float(p3_0[i]), float(p4_0[i]),\
                float(d1_0[i]), float(d2D_0[i]), float(d2L_0[i]), float(d3D_0[i]), float(d3L_0[i]), float(d4D_0[i]), float(d4L_0[i]), \
                float(K0_0[i]), float(K1_0[i]), float(K2_0[i]), float(K2a_0[i]), float(K3_0[i]), float(K4_0[i]), float(K5_0[i]), float(K5b_0[i]), float(K6_0[i]), float(K7_0[i]), float(K7a_0[i]), float(K8_0[i]), float(K9_0[i]), float(K10_0[i])
        pars0 = (v1, v1L, v1A, v2A, v2L, v2B, v3, v3B, v4, v4L, k1L, k1D, k2, k3, k4, p1, p1L, p2, p3, p4, d1, d2D, d2L, d3D, d3L, d4D, d4L, K0, K1, K2, K2a, K3, K4, K5, K5b, K6, K7, K7a, K8, K9, K10)
        y_0 = odeint(f, y0, t, pars0)
        cf = cost_function(y_0)
        if str(cf) == "nan":
            cf = 40000
        delt = np.append(delt, cf)

    delt = list(delt)
    delt_min = heapq.nsmallest(500, delt)
    inde = list(map(delt.index, delt_min))
    df1 = pd.DataFrame({'inde': inde, 'delt': delt_min})
    df1.to_csv('delt_value.csv', index=None)

    list1 = []
    for j in inde:
        v1, v1L, v1A, v2A, v2L, v2B, v3, v3B, v4, v4L, k1L, k1D, k2, k3, k4, p1, p1L, p2, p3, p4, d1, d2D, d2L, d3D, d3L, d4D, d4L, K0, K1, K2, K2a, K3, K4, K5, K5b, K6, K7, K7a, K8, K9, K10 = \
            float(v1_0[i]), float(v1L_0[i]), float(v1A_0[i]), float(v2A_0[i]), float(v2L_0[i]), float(v2B_0[i]), float(v3_0[i]), float(v3B_0[i]), float(v4_0[i]), float(v4L_0[i]), \
                float(k1L_0[i]), float(k1D_0[i]), float(k2_0[i]), float(k3_0[i]), float(k4_0[i]), float(p1_0[i]), float(p1L_0[i]), float(p2_0[i]), float(p3_0[i]), float(p4_0[i]),\
                float(d1_0[i]), float(d2D_0[i]), float(d2L_0[i]), float(d3D_0[i]), float(d3L_0[i]), float(d4D_0[i]), float(d4L_0[i]), \
                float(K0_0[i]), float(K1_0[i]), float(K2_0[i]), float(K2a_0[i]), float(K3_0[i]), float(K4_0[i]), float(K5_0[i]), float(K5b_0[i]), float(K6_0[i]), float(K7_0[i]), float(K7a_0[i]), float(K8_0[i]), float(K9_0[i]), float(K10_0[i])
        pars = (v1, v1L, v1A, v2A, v2L, v2B, v3, v3B, v4, v4L, k1L, k1D, k2, k3, k4, p1, p1L, p2, p3, p4, d1, d2D, d2L, d3D, d3L, d4D, d4L, K0, K1, K2, K2a, K3, K4, K5, K5b, K6, K7, K7a, K8, K9, K10)
        y_0 = odeint(f, y0, t, pars0)
        y = odeint(f, y0, t, pars)
        a = np.round(pars, 2)
        list1.append(a)
    df3 = pd.DataFrame(list1)
    df3.to_csv('parameter_estimation_output.csv', header=None, index=None)
